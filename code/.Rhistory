library(FactoMineR)
library(PerformanceAnalytics)
library(ggrepel)
library(ggplot2)
library(ggfortify)
library(geosphere) # for calculating distances between states
library(reshape2) # for melting data frames into long format
### STATE DATA ###
# read in life tables for all 50 states
path = "/Users/paigepark/repos/us-mortality/data"
states = c("AK", "AL", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS",
"KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY",
"NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA",
"WV", "WI", "WY")
data = list()
for (i in 1:length(states)){
file = paste(states[i], "bltper_1x1.csv", sep = "_")
data[[i]] = read.csv(paste(path, file, sep = "/"))
}
# create dataframe for all states life expectancy at birth
e0 <- lapply(data, function(x) x$ex[x$Age == 65])
full_state_names <- tolower(state.name[match(states, state.abb)]) # full state names to match map
names(e0) = full_state_names
e0_df <- do.call(rbind, e0)
colnames(e0_df) <- c(seq(1959,2020,1))
e0_df <- as.data.frame(e0_df)
# create long version of dataframe
e0_df_long <- e0_df %>%
gather(key = "Year", value = "Life_Expectancy")
e0_df_long <- cbind(states, e0_df_long)
e0_df_long$Year <- as.numeric(e0_df_long$Year)
#### CENSUS DIVSIONS ####
# read in life tables for Census divisions
divisions = c(1:9)
div_data = list()
for (i in 1:length(divisions)){
file = paste("Div", divisions[i], "_bltper_1x1.csv", sep = "")
div_data[[i]] = read.csv(paste(path, file, sep = "/"))
}
# create dataframe for census divisions life expectancy at birth
d_e0 <- lapply(div_data, function(x) x$ex[x$Age == 65])
full_div_names <- c("new england", "middle atlantic", "east north central", "west north central",
"south atlantic","east south central", "west south central", "mountain",
"pacific")
names(d_e0) = full_div_names
div_e0 <- do.call(rbind, d_e0)
colnames(div_e0) <- c(seq(1959,2020,1))
div_e0 = as.data.frame(div_e0)
# create long version of dataframe
e0_df_long_div <- div_e0 %>%
gather(key = "Year", value = "Life_Expectancy")
e0_df_long_div <- cbind(full_div_names, e0_df_long_div)
e0_df_long_div$Year <- as.numeric(e0_df_long_div$Year)
### SET-UP ###
# some packages
library(tidyverse) # version
library(whereami) # version
# path
script_dir <- whereami()
path <- file.path(script_dir, "../../data") # assumes this R script is in a code folder,
# this goes up two levels from current script location
# into the main directory, then back down into data folder
path = normalizePath(path)
### ADDING WRAPPER FUNCTIONS ###
### STRUCTTS ###
# random walk with drift (RWD) specification
rwd <- function(y){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, 0))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
return(list(d = d.hat,
var_innov = var_innov.hat))
}
# structural time series (STS) specification = RWD + observation error
rwd_with_obs_error <- function(y, ..., maxit = 4000){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, NA), ...,
optim.control = list(maxit = maxit))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
var_obs.hat = sts$coef["epsilon"]
names(d.hat) <- names(var_innov.hat) <- names(var_obs.hat) <- ""
return(c(d = d.hat,
var_innov = var_innov.hat,
var_obs = var_obs.hat))
}
# function that estimates drift, variance, and AIC and BIC for RWD
rwd_aic_bic <- function(y){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, 0))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
# get AIC and BIC (have to do this manually)
aic_val = -2*sts$loglik + 2
bic_val = -2*sts$loglik + log(length(y))
return(c(d = d.hat,
var_innov = var_innov.hat,
aic = aic_val,
bic = bic_val))
}
# function that estimates drift, variances, AIC and BIC for STS
rwd_with_obs_aic_bic <- function(y, ..., maxit = 4000){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, NA), ...,
optim.control = list(maxit = maxit))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
var_obs.hat = sts$coef["epsilon"]
names(d.hat) <- names(var_innov.hat) <- names(var_obs.hat) <- ""
# get AIC and BIC (have to do this manually)
aic_val = -2*sts$loglik + 2*2
bic_val = -2*sts$loglik + 2*log(length(y))
return(c(d = d.hat,
var_innov = var_innov.hat,
var_obs = var_obs.hat,
aic = aic_val,
bic = bic_val))
}
# from my research, it seems that StructTS is the least flexible method for structural
# time series estimation. If there is some kind of issue with the optimization leading to
# the 0s, it is hard to adjust anything substantial in the StructTS specifications.
# also, based on my software simulations, it produces more estimates of 0 than it should
# therefore, we also set up function that use the MARSS() package
### MARSS ###
## BFGS ##
rwd_with_obs_error_bfgs <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=1000), method= "BFGS", ...)
if (out2.marss$convergence == 0) {
d = coef(out2.marss)$U[1,1]
var_innov = coef(out2.marss)$Q[1,1]
var_obs = coef(out2.marss)$R[1,1]
} else {
d = NA
var_innov = NA
var_obs = NA
}
names(d) <- names(var_innov) <- names(var_obs) <- ""
return(c(d= d,
var_innov= var_innov,
var_obs = var_obs))
}
# for use with later AIC/AICc function - RWD specification
rwd_bfgs <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix(0), # set the observation var to 0 for rwd
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=3000), method= "BFGS", ...)
return(out2.marss)
}
# for use with later AIC/AICc function - STS specification
rwd_obs_error_bfgs_out <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=3000), method= "BFGS", ...)
return(out2.marss)
}
# AIC/AICc function
get_aic_aicc = function(y, ...) {
rwd_result = rwd_bfgs(y)
obserr_result = rwd_obs_error_bfgs_out(y)
return(c(rwd_result$AIC, obserr_result$AIC, rwd_result$AICc, obserr_result$AICc))
}
# this function needs work - I can get AIC and AICc from the MARSS output, but not the bootstrap AICs
# that are supposedly better for time series. This function can help me do that but its not working
# properly right now
get_aicbp_aicbb <- function(y, ...) {
rwd_result = rwd_bfgs(y)
obserr_result = rwd_obs_error_bfgs_out(y)
rwd_aic = MARSSaic(rwd_result, output = c("AICbp", "AICbb"))
obserr_aic = MARSSaic(obserr_result, output = c("AICbp", "AICbb"))
return(c(rwd_aic, obserr_aic))
}
## KEM ##
rwd_with_obs_error_kem <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=1000), method= "kem", ...)
if (out2.marss$convergence == 0) {
d = coef(out2.marss)$U[1,1]
var_innov = coef(out2.marss)$Q[1,1]
var_obs = coef(out2.marss)$R[1,1]
} else {
d = NA
var_innov = NA
var_obs = NA
}
names(d) <- names(var_innov) <- names(var_obs) <- ""
return(c(d= d,
var_innov= var_innov,
var_obs = var_obs))
}
# No model selection criteria functions created yet for KEM method, could do this later if needed
###### READ IN DATA - SET UP E0 DATASETS - FIT PRELIMINARY MODELS #####
#### ENTIRE US ####
# read in life tables for US
us_data = read.csv(paste(path, "USA_bltper_1x1.csv", sep = "/"))
us_e0 = us_data$ex[us_data$Age == 65]
no2020 = us_e0[1:61]
plot(us_e0)
# fitting the structural time series models to aggregate US data
# with StructTS
us_sts = rwd_with_obs_error(us_e0)
# with MARSS (BFGS and kem)
us_bfgs = rwd_with_obs_error_bfgs(us_e0)
us_kem = rwd_with_obs_error_kem(us_e0)
# this is not converging
# user guide to MARSS suggests that if one of the elements on the diagonal
# of Q or R are going to 0 (are degenerate) then it will take the EM algorithm forever
# to get to 0
rbind(us_sts, us_bfgs, us_kem)
#### STATES ####
# read in life tables for all 50 states
states = c("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS",
"KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY",
"NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA",
"WV", "WI", "WY")
state_data = list()
for (i in 1:length(states)){
file = paste(states[i], "bltper_1x1.csv", sep = "_")
state_data[[i]] = read.csv(paste(path, file, sep = "/"))
}
# create dataframe for all states life expectancy at birth
s_e0 <- lapply(state_data, function(x) x$ex[x$Age == 65])
full_state_names <- tolower(state.name[match(states, state.abb)]) # full state names to match map
names(s_e0) = full_state_names
state_e0 <- do.call(rbind, s_e0)
colnames(state_e0) <- c(seq(1959,2020,1))
# create data with 2020 removed for testing impact of 2020 mortality on models
s_no2020 = state_e0[, -62]
View(state_e0)
# read in life tables for all 50 states
states = c("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS",
"KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY",
"NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA",
"WV", "WI", "WY")
state_data = list()
for (i in 1:length(states)){
file = paste(states[i], "bltper_1x1.csv", sep = "_")
state_data[[i]] = read.csv(paste(path, file, sep = "/"))
}
# create dataframe for all states life expectancy at birth
s_e0 <- lapply(state_data, function(x) x$ex[x$Age == 65])
full_state_names <- tolower(state.name[match(states, state.abb)]) # full state names to match map
names(s_e0) = full_state_names
state_e0 <- do.call(rbind, s_e0)
colnames(state_e0) <- c(seq(1959,2020,1))
# create data with 2020 removed for testing impact of 2020 mortality on models
s_no2020 = state_e0[, -62]
# create data with tenths of years of life expectancy as the units for less 0s
state_e0_tenths = state_e0 * 10
View(state_e0_tenths)
state_bfgs = matrix(NA, nrow=50, ncol=3)
# state_bfgs = as.data.frame(apply(state_e0, 1, rwd_with_obs_error_bfgs))
state_bfgs = as.data.frame(apply(state_e0_tenths, 1, rwd_with_obs_error_bfgs))
View(state_bfgs)
state_bfgs = matrix(NA, nrow=50, ncol=3)
state_bfgs = as.data.frame(apply(state_e0, 1, rwd_with_obs_error_bfgs))
View(state_bfgs)
# construct MARSS BFGS table
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
# load in population data from the Census (data includes pop by state from 1985 to 1989)
pop_89 = read.csv(paste(path, "89_pop.csv", sep = "/"), header = TRUE, row.names = 1)
pop_89 = pop_89["Jul.89"] # filter to just year 1989
samp_sd = 150/sqrt(pop_89) # create sampling standard deviation estimates using N from 89 (approximation given in Hanley 2022)
samp_sd = subset(samp_sd, !(rownames(samp_sd) %in% c("US", "DC"))) # get rid of observations not in USMDB
##### GENERATING TABLES OF DRIFT, INNOV SD, OBS SD, SAMPLING SD, & SHOCK SD #####
library(knitr)
library(kableExtra)
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
state_bfgs_table = state_bfgs_table %>%
mutate(shock_sd = var_obs - Jul.89^2) %>% # get shock sd through additive property of var
mutate(var_innov = sqrt(var_innov), var_obs = sqrt(var_obs), shock_sd = sqrt(shock_sd)) # changing all of the variances to SDs
colnames(state_bfgs_table) = c("drift", "process_SD", "observation_SD", "sampling_SD", "shock_SD")
state_bfgs_table$shock_SD <- ifelse(state_bfgs_table$shock_SD < 0, NA, state_bfgs_table$shock_SD)
# round
library(scales)
state_bfgs_table_round <- data.frame(lapply(state_bfgs_table, function(x) if(is.numeric(x)) number(x, accuracy = 0.00000001) else x))
# convert cells with 0 to red
state_bfgs_table_red = state_bfgs_table_round
format_cell = function(cell_value) {
if (is.na(cell_value)) {
return(cell_spec("~0", "latex", background = "gray"))
} else {
cell_spec(cell_value, "latex", background = ifelse(cell_value <= "0.00010000", "#FF9999", "white")) # changing this code to capture near 0 results in red
}
}
state_bfgs_table_red[] = as.data.frame(sapply(state_bfgs_table_round, function(col) {
sapply(col, format_cell)
}))
rownames(state_bfgs_table_red) <- rownames(state_bfgs_table)
# get latex code for MARSS BFGS
kable(state_bfgs_table_red, caption = "MARSS BFGS Results", format="latex", escape = FALSE) %>%
kable_styling()
# construct MARSS BFGS table
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
state_bfgs_table = state_bfgs_table %>%
mutate(shock_sd = var_obs - Jul.89^2) %>% # get shock sd through additive property of var
mutate(var_innov = sqrt(var_innov), var_obs = sqrt(var_obs), shock_sd = sqrt(shock_sd)) # changing all of the variances to SDs
colnames(state_bfgs_table) = c("drift", "process_SD", "observation_SD", "sampling_SD", "shock_SD")
state_bfgs_table$shock_SD <- ifelse(state_bfgs_table$shock_SD < 0, NA, state_bfgs_table$shock_SD)
# round
library(scales)
state_bfgs_table_round <- data.frame(lapply(state_bfgs_table, function(x) if(is.numeric(x)) number(x, accuracy = 0.001) else x))
# convert cells with 0 to red
state_bfgs_table_red = state_bfgs_table_round
format_cell = function(cell_value) {
if (is.na(cell_value)) {
return(cell_spec("~0", "latex", background = "gray"))
} else {
cell_spec(cell_value, "latex", background = ifelse(cell_value <= "0.00010000", "#FF9999", "white")) # changing this code to capture near 0 results in red
}
}
state_bfgs_table_red[] = as.data.frame(sapply(state_bfgs_table_round, function(col) {
sapply(col, format_cell)
}))
rownames(state_bfgs_table_red) <- rownames(state_bfgs_table)
pop_89 = read.csv(paste(path, "89_pop.csv", sep = "/"), header = TRUE, row.names = 1)
pop_89 = pop_89["Jul.89"] # filter to just year 1989
samp_sd = 150/sqrt(pop_89) # create sampling standard deviation estimates using N from 89 (approximation given in Hanley 2022)
samp_sd = subset(samp_sd, !(rownames(samp_sd) %in% c("US", "DC"))) # get rid of observations not in USMDB
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
state_bfgs_table = state_bfgs_table %>%
mutate(shock_sd = var_obs - Jul.89^2) %>% # get shock sd through additive property of var
mutate(var_innov = sqrt(var_innov), var_obs = sqrt(var_obs), shock_sd = sqrt(shock_sd)) # ch
View(state_bfgs_table)
View(state_bfgs_table_red)
View(state_bfgs_table)
View(state_bfgs_table_round)
View(state_bfgs_table)
library(scales)
state_bfgs_table_round <- data.frame(lapply(state_bfgs_table, function(x) if(is.numeric(x)) number(x, accuracy = 0.001) else x))
# convert cells with 0 to red
state_bfgs_table_red = state_bfgs_table_round
format_cell = function(cell_value) {
if (is.na(cell_value)) {
return(cell_spec("Approx. 0", "latex"))
} else {
cell_spec(cell_value, "latex", background = ifelse(cell_value <= "0.00010000", "#FF9999", "white")) # changing this code to capture near 0 results in red
}
}
state_bfgs_table_red[] = as.data.frame(sapply(state_bfgs_table_round, function(col) {
sapply(col, format_cell)
}))
rownames(state_bfgs_table_red) <- rownames(state_bfgs_table)
# get latex code for MARSS BFGS
kable(state_bfgs_table_red, caption = "MARSS BFGS Results", format="latex", escape = FALSE) %>%
kable_styling()
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
state_bfgs_table = state_bfgs_table %>%
mutate(shock_sd = var_obs - Jul.89^2) %>% # get shock sd through additive property of var
mutate(var_innov = sqrt(var_innov), var_obs = sqrt(var_obs), shock_sd = sqrt(shock_sd)) # changing all of the variances to SDs
colnames(state_bfgs_table) = c("drift", "process SD", "observation SD", "sampling SD", "shock SD")
# state_bfgs_table$shock_SD <- ifelse(state_bfgs_table$shock_SD < 0, NA, state_bfgs_table$shock_SD)
# round
library(scales)
state_bfgs_table_round <- data.frame(lapply(state_bfgs_table, function(x) if(is.numeric(x)) number(x, accuracy = 0.001) else x))
# convert cells with 0 to red
state_bfgs_table_red = state_bfgs_table_round
format_cell = function(cell_value) {
if (is.na(cell_value)) {
return(cell_spec("~ 0", "latex"))
} else {
cell_spec(cell_value, "latex", background = ifelse(cell_value <= "0.00010000", "#FF9999", "white")) # changing this code to capture near 0 results in red
}
}
state_bfgs_table_red[] = as.data.frame(sapply(state_bfgs_table_round, function(col) {
sapply(col, format_cell)
}))
rownames(state_bfgs_table_red) <- rownames(state_bfgs_table)
# get latex code for MARSS BFGS
kable(state_bfgs_table_red, caption = "MARSS BFGS Results", format="latex", escape = FALSE) %>%
kable_styling()
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
state_bfgs_table = state_bfgs_table %>%
mutate(shock_sd = var_obs - Jul.89^2) %>% # get shock sd through additive property of var
mutate(var_innov = sqrt(var_innov), var_obs = sqrt(var_obs), shock_sd = sqrt(shock_sd)) # changing all of the variances to SDs
colnames(state_bfgs_table) = c("drift", "process SD", "observation SD", "sampling SD", "shock SD")
# state_bfgs_table$shock_SD <- ifelse(state_bfgs_table$shock_SD < 0, NA, state_bfgs_table$shock_SD)
# round
library(scales)
state_bfgs_table_round <- data.frame(lapply(state_bfgs_table, function(x) if(is.numeric(x)) number(x, accuracy = 0.001) else x))
# convert cells with 0 to red
state_bfgs_table_red = state_bfgs_table_round
format_cell = function(cell_value) {
if (is.na(cell_value)) {
return(cell_spec("unmeasurable", "latex"))
} else {
cell_spec(cell_value, "latex", background = ifelse(cell_value <= "0.00010000", "#FF9999", "white")) # changing this code to capture near 0 results in red
}
}
state_bfgs_table_red[] = as.data.frame(sapply(state_bfgs_table_round, function(col) {
sapply(col, format_cell)
}))
rownames(state_bfgs_table_red) <- rownames(state_bfgs_table)
# get latex code for MARSS BFGS
kable(state_bfgs_table_red, caption = "MARSS BFGS Results", format="latex", escape = FALSE) %>%
kable_styling()
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
state_bfgs_table = state_bfgs_table %>%
mutate(shock_sd = var_obs - Jul.89^2) %>% # get shock sd through additive property of var
mutate(var_innov = sqrt(var_innov), var_obs = sqrt(var_obs), shock_sd = sqrt(shock_sd)) # changing all of the variances to SDs
colnames(state_bfgs_table) = c("drift", "process SD", "observation SD", "sampling SD", "shock SD")
# state_bfgs_table$shock_SD <- ifelse(state_bfgs_table$shock_SD < 0, NA, state_bfgs_table$shock_SD)
# round
library(scales)
state_bfgs_table_round <- data.frame(lapply(state_bfgs_table, function(x) if(is.numeric(x)) number(x, accuracy = 0.001) else x))
# convert cells with 0 to red
state_bfgs_table_red = state_bfgs_table_round
format_cell = function(cell_value) {
if (is.na(cell_value)) {
return(cell_spec("*", "latex"))
} else {
cell_spec(cell_value, "latex", background = ifelse(cell_value <= "0.00010000", "#FF9999", "white")) # changing this code to capture near 0 results in red
}
}
state_bfgs_table_red[] = as.data.frame(sapply(state_bfgs_table_round, function(col) {
sapply(col, format_cell)
}))
rownames(state_bfgs_table_red) <- rownames(state_bfgs_table)
# get latex code for MARSS BFGS
kable(state_bfgs_table_red, caption = "MARSS BFGS Results", format="latex", escape = FALSE) %>%
kable_styling()
# construct MARSS BFGS table
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
state_bfgs_table = state_bfgs_table %>%
mutate(shock_sd = var_obs - Jul.89^2) %>% # get shock sd through additive property of var
mutate(var_innov = sqrt(var_innov), var_obs = sqrt(var_obs), shock_sd = sqrt(shock_sd)) # changing all of the variances to SDs
colnames(state_bfgs_table) = c("drift", "process SD", "observation SD", "sampling SD", "shock SD")
# state_bfgs_table$shock_SD <- ifelse(state_bfgs_table$shock_SD < 0, NA, state_bfgs_table$shock_SD)
# round
library(scales)
state_bfgs_table_round <- data.frame(lapply(state_bfgs_table, function(x) if(is.numeric(x)) number(x, accuracy = 0.001) else x))
# convert cells with 0 to red
state_bfgs_table_red = state_bfgs_table_round
format_cell = function(cell_value) {
if (is.na(cell_value)) {
return(cell_spec("\approx 0", "latex"))
} else {
cell_spec(cell_value, "latex", background = ifelse(cell_value <= "0.00010000", "#FF9999", "white")) # changing this code to capture near 0 results in red
}
}
state_bfgs_table_red[] = as.data.frame(sapply(state_bfgs_table_round, function(col) {
sapply(col, format_cell)
}))
rownames(state_bfgs_table_red) <- rownames(state_bfgs_table)
# get latex code for MARSS BFGS
kable(state_bfgs_table_red, caption = "MARSS BFGS Results", format="latex", escape = FALSE) %>%
kable_styling()
state_bfgs_table = t(state_bfgs)
state_bfgs_table = as.data.frame(cbind(state_bfgs_table, samp_sd))
state_bfgs_table = state_bfgs_table %>%
mutate(shock_sd = var_obs - Jul.89^2) %>% # get shock sd through additive property of var
mutate(var_innov = sqrt(var_innov), var_obs = sqrt(var_obs), shock_sd = sqrt(shock_sd)) # changing all of the variances to SDs
colnames(state_bfgs_table) = c("drift", "process SD", "observation SD", "sampling SD", "shock SD")
# state_bfgs_table$shock_SD <- ifelse(state_bfgs_table$shock_SD < 0, NA, state_bfgs_table$shock_SD)
# round
library(scales)
state_bfgs_table_round <- data.frame(lapply(state_bfgs_table, function(x) if(is.numeric(x)) number(x, accuracy = 0.001) else x))
# convert cells with 0 to red
state_bfgs_table_red = state_bfgs_table_round
format_cell = function(cell_value) {
if (is.na(cell_value)) {
return(cell_spec("$\sim$ 0", "latex"))
state_bfgs_tenths = matrix(NA, nrow=50, ncol=3)
#state_bfgs = as.data.frame(apply(state_e0, 1, rwd_with_obs_error_bfgs))
state_bfgs_tenths = as.data.frame(apply(state_e0_tenths, 1, rwd_with_obs_error_bfgs))
View(state_e0_tenths)
View(state_e0_tenths)
View(state_bfgs_table)
View(state_bfgs_table_red)
View(state_bfgs_table)
View(state_bfgs_table_red)
View(state_bfgs)
View(state_bfgs_table)
