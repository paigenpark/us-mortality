script_dir <- whereami()
path <- file.path(script_dir, "../../data") # assumes this R script is in a code folder,
# this goes up two levels from current script location
# into the main directory, then back down into data folder
path = normalizePath(path)
### ADDING WRAPPER FUNCTIONS ###
### STRUCTTS ###
# random walk with drift (RWD) specification
rwd <- function(y){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, 0))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
return(list(d = d.hat,
var_innov = var_innov.hat))
}
# structural time series (STS) specification = RWD + observation error
rwd_with_obs_error <- function(y, ..., maxit = 4000){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, NA), ...,
optim.control = list(maxit = maxit))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
var_obs.hat = sts$coef["epsilon"]
names(d.hat) <- names(var_innov.hat) <- names(var_obs.hat) <- ""
return(c(d = d.hat,
var_innov = var_innov.hat,
var_obs = var_obs.hat))
}
# function that estimates drift, variance, and AIC and BIC for RWD
rwd_aic_bic <- function(y){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, 0))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
# get AIC and BIC (have to do this manually)
aic_val = -2*sts$loglik + 2
bic_val = -2*sts$loglik + log(length(y))
return(c(d = d.hat,
var_innov = var_innov.hat,
aic = aic_val,
bic = bic_val))
}
# function that estimates drift, variances, AIC and BIC for STS
rwd_with_obs_aic_bic <- function(y, ..., maxit = 4000){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, NA), ...,
optim.control = list(maxit = maxit))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
var_obs.hat = sts$coef["epsilon"]
names(d.hat) <- names(var_innov.hat) <- names(var_obs.hat) <- ""
# get AIC and BIC (have to do this manually)
aic_val = -2*sts$loglik + 2*2
bic_val = -2*sts$loglik + 2*log(length(y))
return(c(d = d.hat,
var_innov = var_innov.hat,
var_obs = var_obs.hat,
aic = aic_val,
bic = bic_val))
}
# from my research, it seems that StructTS is the least flexible method for structural
# time series estimation. If there is some kind of issue with the optimization leading to
# the 0s, it is hard to adjust anything substantial in the StructTS specifications.
# also, based on my software simulations, it produces more estimates of 0 than it should
# therefore, we also set up function that use the MARSS() package
### MARSS ###
## BFGS ##
rwd_with_obs_error_bfgs <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=1000), method= "BFGS", ...)
if (out2.marss$convergence == 0) {
d = coef(out2.marss)$U[1,1]
var_innov = coef(out2.marss)$Q[1,1]
var_obs = coef(out2.marss)$R[1,1]
} else {
d = NA
var_innov = NA
var_obs = NA
}
names(d) <- names(var_innov) <- names(var_obs) <- ""
return(c(d= d,
var_innov= var_innov,
var_obs = var_obs))
}
# for use with later AIC/AICc function - RWD specification
rwd_bfgs <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix(0), # set the observation var to 0 for rwd
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=3000), method= "BFGS", ...)
return(out2.marss)
}
# for use with later AIC/AICc function - STS specification
rwd_obs_error_bfgs_out <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=3000), method= "BFGS", ...)
return(out2.marss)
}
# AIC/AICc function
get_aic_aicc = function(y, ...) {
rwd_result = rwd_bfgs(y)
obserr_result = rwd_obs_error_bfgs_out(y)
return(c(rwd_result$AIC, obserr_result$AIC, rwd_result$AICc, obserr_result$AICc))
}
# this function needs work - I can get AIC and AICc from the MARSS output, but not the bootstrap AICs
# that are supposedly better for time series. This function can help me do that but its not working
# properly right now
get_aicbp_aicbb <- function(y, ...) {
rwd_result = rwd_bfgs(y)
obserr_result = rwd_obs_error_bfgs_out(y)
rwd_aic = MARSSaic(rwd_result, output = c("AICbp", "AICbb"))
obserr_aic = MARSSaic(obserr_result, output = c("AICbp", "AICbb"))
return(c(rwd_aic, obserr_aic))
}
## KEM ##
rwd_with_obs_error_kem <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=1000), method= "kem", ...)
if (out2.marss$convergence == 0) {
d = coef(out2.marss)$U[1,1]
var_innov = coef(out2.marss)$Q[1,1]
var_obs = coef(out2.marss)$R[1,1]
} else {
d = NA
var_innov = NA
var_obs = NA
}
names(d) <- names(var_innov) <- names(var_obs) <- ""
return(c(d= d,
var_innov= var_innov,
var_obs = var_obs))
}
# No model selection criteria functions created yet for KEM method, could do this later if needed
###### READ IN DATA - SET UP E0 DATASETS - FIT PRELIMINARY MODELS #####
#### ENTIRE US ####
# read in life tables for US
us_data = read.csv(paste(path, "USA_bltper_1x1.csv", sep = "/"))
us_e0 = us_data$ex[us_data$Age == 0]
no2020 = us_e0[1:61]
plot(us_e0)
# fitting the structural time series models to aggregate US data
# with StructTS
us_sts = rwd_with_obs_error(us_e0)
# with MARSS (BFGS and kem)
us_bfgs = rwd_with_obs_error_bfgs(us_e0)
us_kem = rwd_with_obs_error_kem(us_e0)
# this is not converging
# user guide to MARSS suggests that if one of the elements on the diagonal
# of Q or R are going to 0 (are degenerate) then it will take the EM algorithm forever
# to get to 0
rbind(us_sts, us_bfgs, us_kem)
# read in life tables for all 50 states
states = c("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS",
"KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY",
"NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA",
"WV", "WI", "WY")
state_data = list()
for (i in 1:length(states)){
file = paste(states[i], "bltper_1x1.csv", sep = "_")
state_data[[i]] = read.csv(paste(path, file, sep = "/"))
}
# create dataframe for all states life expectancy at birth
s_e0 <- lapply(state_data, function(x) x$ex[x$Age == 0])
full_state_names <- tolower(state.name[match(states, state.abb)]) # full state names to match map
names(s_e0) = full_state_names
state_e0 <- do.call(rbind, s_e0)
colnames(state_e0) <- c(seq(1959,2020,1))
# create data with 2020 removed for testing impact of 2020 mortality on models
s_no2020 = state_e0[, -62]
state_sts = matrix(NA, nrow=50, ncol=3)
state_sts = as.data.frame(apply(state_e0, 1, rwd_with_obs_error))
rwd_with_obs_error <- function(y, ..., maxit = 5000){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, NA), ...,
optim.control = list(maxit = maxit))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
var_obs.hat = sts$coef["epsilon"]
names(d.hat) <- names(var_innov.hat) <- names(var_obs.hat) <- ""
return(c(d = d.hat,
var_innov = var_innov.hat,
var_obs = var_obs.hat))
}
state_sts = matrix(NA, nrow=50, ncol=3)
state_sts = as.data.frame(apply(state_e0, 1, rwd_with_obs_error))
#
View(state_sts)
# get names of states with var_obs = 0
state_no_obs_sts = which(state_sts[3,]==0)
state_no_obs_sts = colnames(state_sts)[state_no_obs_sts]
state_no_obs_sts
state_no_obs_bfgs = which(state_bfgs[3,]<=0.0000000001)
state_bfgs = matrix(NA, nrow=50, ncol=3)
state_bfgs = as.data.frame(apply(state_e0, 1, rwd_with_obs_error_bfgs))
state_no_obs_bfgs = which(state_bfgs[3,]<=0.0000000001)
state_no_obs_bfgs = colnames(state_bfgs)[state_no_obs_bfgs]
state_no_obs_bfgs
barchart_data <- data.frame(
state = full_state_names,
MARSS_BFGS = full_state_names %in% state_no_obs_bfgs,
StructTS = full_state_names %in% state_no_obs_sts
)
long_data <- pivot_longer(barchart_data, cols = c(MARSS_BFGS, StructTS), names_to = "method", values_to = "has_no_obs")
# Filter to keep only TRUE values
long_data <- long_data[long_data$has_no_obs == TRUE, ]
# Create a stacked bar chart
ggplot(long_data, aes(x = method, fill = state)) +
geom_bar() +
labs(y = "Count of States with Estimate of Zero Transitory Shocks", fill = "State") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Adjust the x-axis labels if necessary
# Create a stacked bar chart
ggplot(long_data, aes(x = method, fill = state)) +
geom_bar() +
labs(y = "Count of States with Estimate of Zero Transitory Shocks", fill = "State", x=NULL) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Adjust the x-axis labels if necessary
# Create a stacked bar chart
ggplot(long_data, aes(x = method, fill = state)) +
geom_bar() +
labs(y = "Count of States with Estimate of Zero for Observation Variance", fill = "State", x=NULL) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) # Adjust the x-axis labels if necessary
boot_results = read.csv(paste(path, "boot_results.csv", sep = "/"), header = TRUE, row.names = 1)
# the e0.var column in boot_results should replace the samp_var column in the prior table
# the sd column in boot_results can be used to calculate confidence intervals for the samp_var column
# to get sd/ci for first three columns of the table we're constructing, we need to get these from the
# MARSS output
set.seed(10)
marss_out <- apply(state_e0, 1, rwd_obs_error_bfgs_out)
bfgs_with_cis <- lapply(marss_out, MARSSparamCIs)
obs_var_new <- unlist(lapply(marss_out, function(x) coef(x)$R[1,1]))
# to get the sd/ci for the shock_sd column, we need to subtract cis from obs_var and samp_var (I think
# this will work anyway)
# to produce a conservative interval for shock variance, we need to subtract the lower bound obs var interval
# from the upper bound samp var interval and vice versa
# this gives the widest and most conservative interval of the shock variance
# R param = observation variance
obs_lb <- unlist(lapply(bfgs_with_cis, function(x) x[[26]][['R']]))
obs_ub <- unlist(lapply(bfgs_with_cis, function(x) x[[25]][['R']]))
samp_lb <- boot_results$e0.var - 2 * boot_results$se_of_var_e0
samp_ub <- boot_results$e0.var + 2 * boot_results$se_of_var_e0
shock_lb <- obs_lb - samp_ub
shock_ub <- obs_ub - samp_lb
shock_mean <- obs_var_new - boot_results$e0.var
library(ggplot2)
# prepare data
data <- data.frame(
State = factor(names(shock_lb)),
Mean = shock_mean,
Lower = shock_lb,
Upper = shock_ub
)
data$State <- reorder(data$State, data$Mean)
# Dot chart with confidence intervals
ggplot(data, aes(x = State, y = Mean)) +
geom_point() +
geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.2) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
coord_flip() +
xlab("") +
ylab("Shock Variance") +
theme_minimal()
data <- data.frame(
State = factor(names(shock_lb)),
Mean = shock_mean^2,
Lower = shock_lb^2,
Upper = shock_ub^2
)
data$State <- reorder(data$State, data$Mean)
# Dot chart with confidence intervals
ggplot(data, aes(x = State, y = Mean)) +
geom_point() +
geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.2) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
coord_flip() +
xlab("") +
ylab("Shock Variance") +
theme_minimal()
library(tidyverse) # version
library(whereami) # version
# path
script_dir <- whereami()
path <- file.path(script_dir, "../../data") # assumes this R script is in a code folder,
# this goes up two levels from current script location
# into the main directory, then back down into data folder
path = normalizePath(path)
### STRUCTTS ###
# random walk with drift (RWD) specification
rwd <- function(y){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, 0))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
return(list(d = d.hat,
var_innov = var_innov.hat))
}
# structural time series (STS) specification = RWD + observation error
rwd_with_obs_error <- function(y, ..., maxit = 5000){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, NA), ...,
optim.control = list(maxit = maxit))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
var_obs.hat = sts$coef["epsilon"]
names(d.hat) <- names(var_innov.hat) <- names(var_obs.hat) <- ""
return(c(d = d.hat,
var_innov = var_innov.hat,
var_obs = var_obs.hat))
}
# function that estimates drift, variance, and AIC and BIC for RWD
rwd_aic_bic <- function(y){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, 0))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
# get AIC and BIC (have to do this manually)
aic_val = -2*sts$loglik + 2
bic_val = -2*sts$loglik + log(length(y))
return(c(d = d.hat,
var_innov = var_innov.hat,
aic = aic_val,
bic = bic_val))
}
# function that estimates drift, variances, AIC and BIC for STS
rwd_with_obs_aic_bic <- function(y, ..., maxit = 4000){
sts = StructTS(x = y, type = "trend", fixed = c(NA, 0, NA), ...,
optim.control = list(maxit = maxit))
d.hat = sts$model$a[2]
var_innov.hat = sts$coef["level"]
var_obs.hat = sts$coef["epsilon"]
names(d.hat) <- names(var_innov.hat) <- names(var_obs.hat) <- ""
# get AIC and BIC (have to do this manually)
aic_val = -2*sts$loglik + 2*2
bic_val = -2*sts$loglik + 2*log(length(y))
return(c(d = d.hat,
var_innov = var_innov.hat,
var_obs = var_obs.hat,
aic = aic_val,
bic = bic_val))
}
# from my research, it seems that StructTS is the least flexible method for structural
# time series estimation. If there is some kind of issue with the optimization leading to
# the 0s, it is hard to adjust anything substantial in the StructTS specifications.
# also, based on my software simulations, it produces more estimates of 0 than it should
# therefore, we also set up function that use the MARSS() package
### MARSS ###
## BFGS ##
rwd_with_obs_error_bfgs <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=1000), method= "BFGS", ...)
if (out2.marss$convergence == 0) {
d = coef(out2.marss)$U[1,1]
var_innov = coef(out2.marss)$Q[1,1]
var_obs = coef(out2.marss)$R[1,1]
} else {
d = NA
var_innov = NA
var_obs = NA
}
names(d) <- names(var_innov) <- names(var_obs) <- ""
return(c(d= d,
var_innov= var_innov,
var_obs = var_obs))
}
# for use with later AIC/AICc function - RWD specification
rwd_bfgs <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix(0), # set the observation var to 0 for rwd
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=3000), method= "BFGS", ...)
return(out2.marss)
}
# for use with later AIC/AICc function - STS specification
rwd_obs_error_bfgs_out <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=3000), method= "BFGS", ...)
return(out2.marss)
}
# AIC/AICc function
get_aic_aicc = function(y, ...) {
rwd_result = rwd_bfgs(y)
obserr_result = rwd_obs_error_bfgs_out(y)
return(c(rwd_result$AIC, obserr_result$AIC, rwd_result$AICc, obserr_result$AICc))
}
# this function needs work - I can get AIC and AICc from the MARSS output, but not the bootstrap AICs
# that are supposedly better for time series. This function can help me do that but its not working
# properly right now
get_aicbp_aicbb <- function(y, ...) {
rwd_result = rwd_bfgs(y)
obserr_result = rwd_obs_error_bfgs_out(y)
rwd_aic = MARSSaic(rwd_result, output = c("AICbp", "AICbb"))
obserr_aic = MARSSaic(obserr_result, output = c("AICbp", "AICbb"))
return(c(rwd_aic, obserr_aic))
}
## KEM ##
rwd_with_obs_error_kem <- function(y, ...)
{
library(MARSS)
mod.list.2 <- list(B = matrix(1),
U = matrix("d"),
Q = matrix("q"),
Z = matrix(1),
A = matrix(0),
R = matrix("r"),
x0 = matrix("mu"),
tinitx = 0)
out2.marss = MARSS(y, model = mod.list.2, control=list(maxit=1000), method= "kem", ...)
if (out2.marss$convergence == 0) {
d = coef(out2.marss)$U[1,1]
var_innov = coef(out2.marss)$Q[1,1]
var_obs = coef(out2.marss)$R[1,1]
} else {
d = NA
var_innov = NA
var_obs = NA
}
names(d) <- names(var_innov) <- names(var_obs) <- ""
return(c(d= d,
var_innov= var_innov,
var_obs = var_obs))
}
# No model selection criteria functions created yet for KEM method, could do this later if needed
#### STATES ####
# read in life tables for all 50 states
states = c("AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS",
"KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY",
"NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX", "UT", "VT", "VA", "WA",
"WV", "WI", "WY")
state_data = list()
for (i in 1:length(states)){
file = paste(states[i], "bltper_1x1.csv", sep = "_")
state_data[[i]] = read.csv(paste(path, file, sep = "/"))
}
# create dataframe for all states life expectancy at birth
s_e0 <- lapply(state_data, function(x) x$ex[x$Age == 0])
full_state_names <- tolower(state.name[match(states, state.abb)]) # full state names to match map
names(s_e0) = full_state_names
state_e0 <- do.call(rbind, s_e0)
colnames(state_e0) <- c(seq(1959,2020,1))
# create data with 2020 removed for testing impact of 2020 mortality on models
s_no2020 = state_e0[, -62]
View(state_e0)
rwd_bfgs(state_e0[,"virginia"])
rwd_bfgs(state_e0[,45])
state_e0[,45]
rwd_bfgs(state_e0[45,])
rwd_obs_error_bfgs_out(state_e0[45,])
state_e0[45,]
rwd_obs_error_bfgs_out(state_e0[46,])
test= rwd_obs_error_bfgs_out(state_e0[46,])
test.coef
test= rwd_obs_error_bfgs_out(state_e0[46,])
test.coef
View(test)
rwd_with_obs_error_bfgs(state_e0[46,])
sqrt(.0857)
sqrt(0.00554474)
?MARSS
View(test)
